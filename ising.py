import numpy as np
import matplotlib.pyplot as plt
from numba import jit
from itertools import permutations

class Ising:
    def __init__(self,N=100):
        self.N = N ##number of methylation sites
        self.m = np.zeros(N,dtype=np.bool_) ##methylation state vector
        self.m0 = self.m.copy()
        self.p0 = None ##initial proportion methylated

        self.kern = None
        self.nk = None
        self.combo_idx = None
        self.window_idx = None

        self.rates = None

        self.dt = None
        self.tfin = None
        self.t_span = None
        self.nT = None
        self.rates_dt = None

        self.m_save = None

    def generate_init(self,p0):
        """
        Generates an initial boolean state vector m, with a fraction of methylation p0
        :param p0: fraction of methylation (float)
        :return:
        """
        self.p0 = p0
        self.m0 = np.random.random(self.N)<p0
        self.m = self.m0.copy()

    def load_init(self,m):
        """
        Load the initial condition, alternative to generate_init.

        :param m: np.ndarray of size (N,), of dtype np.bool_
        :return:
        """
        self.m0 = m
        self.m = self.m0.copy()
        self.N = self.m.size

    def make_conv_kernels(self,nk = 2):
        """
        Makes the kernels that allow for the detection of different states.
        A 'state' of a given methylation site is defined by the methylation composition of a site and its neighbours.
        For nk = 2, this is defined by three boolean variables: methylation to the left, methylation of the site in question, methylation to the right.

        This is generalizable to longer-range 'interactions'

        :param nk: window size.
        :return:
        """
        self.nk = nk
        nkern = 2*nk-1
        combinations = np.array(np.meshgrid(*[[False,True] for i in range(nkern)]))
        combinations = combinations.reshape(nkern,-1)
        self.kern = np.zeros((combinations.shape[1],nkern),dtype=np.bool_)
        for i, combo in enumerate(combinations.T):
            self.kern[i] = combo
        self.combo_idx = np.arange(combinations.shape[1])
        self.window_idx = np.arange(-nk + 1, nk )

    def assign_transition_rates(self,rates):
        """
        Assigns the transition rates, given each "state", as defined by the kernels above.
        Needs to be the same length as the number of kernels, in turn defined by the kernel window size.

        This assumes that transition rates are position independent (after accounting for the composition of the neighbourhood), which may or may not be true.
        Could for example scale the transition rates at each base by a scalar if this position indpendence assumption is invalid

        :param rates: np.ndarray of transition rates, given in the same order as the kernels (autogenerated in the function above)
        :return:
        """
        self.rates = rates
        if self.rates.size != self.kern.shape[0]:
            print("Number of rates =/= number of combinations")

    def set_t_span(self,dt,tfin):
        """
        Set temporal parameters.

        Note that this is a bit dodgy, as the simulation doesn't evaluate transitions simultaneously and rather considers a single potential transition per time-step.
        I'll have a think about how legit this is.

        :param dt: time step
        :param tfin: final time
        :return:
        """
        self.dt = dt
        self.tfin = tfin
        self.t_span = np.arange(0,tfin,dt)
        self.nT = self.t_span.size

        self.rates_dt = self.rates*self.dt

        if (self.rates_dt > 1).any():
            print("dt or rates are too high, meaning probabilities of transitioning exceeds 1. Reduce")

    def evaluate_kernel_i(self,i):
        """
        Find the 'state' of the position i (i.e. methylation state and that of its neighbours)
        Returns an int whose max is the number of possible combinations given the chosen convolution window size (i.e. len(self.kern))
        :param i: Position of a methylation site
        :return:
        """
        return eval_kern_i(i, self.m,self.combo_idx,self.N,self.kern,self.window_idx)

    def evaluate_kernel_all(self):
        """
        Find the 'state' of all positions.
        :return:
        """
        return eval_kern_all(self.m,self.combo_idx,self.N,self.kern,self.window_idx)

    def simulate(self,skip=1):
        self.m_save = simulate(self.m,self.combo_idx,self.N,self.kern,self.window_idx,self.rates_dt,self.nT,skip=skip)


##I've 'jitted' some of these functions as it massively improves efficiency. Hence some slightly convoluted means of expressing certain operations. Hope clear nonetheless.

@jit(nopython=True)
def eval_kern_i(i, m,combo_idx,N,kern,window_idx):
    idx = np.mod(window_idx+i,N)
    return np.sum(combo_idx*(((m[idx] == kern).sum(axis=1) == 3)*1))


@jit(nopython=True)
def eval_kern_all(m,combo_idx,N,kern,window_idx):
    kernel_type = np.zeros(N,dtype=np.int64)
    for i in range(N):
        idx = np.mod(window_idx+i,N)
        kernel_type[i] = np.sum(combo_idx*(((m[idx] == kern).sum(axis=1) == 3)*1))
    return kernel_type

@jit(nopython=True)
def simulate(m,combo_idx,N,kern,window_idx,rates_dt,nT,skip=1):
    m_save = np.zeros((int(np.ceil(nT/skip)),m.size),dtype=np.bool_)
    t_save = 0
    for ti in range(nT):
        i = int(np.random.random()*N)#choose random point
        kern_type = eval_kern_i(i, m,combo_idx,N,kern,window_idx)
        rate = rates_dt[kern_type]
        if np.random.random() < rate:
            m[i] = ~m[i]
        if ti % skip == 0:
            m_save[t_save] = m
            t_save += 1
    m_save = m_save[:t_save-1]
    return m_save



